// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AssetAttributeList asset attribute list
//
// swagger:model AssetAttributeList
type AssetAttributeList []*AssetAttributeListItems0

// Validate validates this asset attribute list
func (m AssetAttributeList) Validate(formats strfmt.Registry) error {
	var res []error

	for i := 0; i < len(m); i++ {
		if swag.IsZero(m[i]) { // not required
			continue
		}

		if m[i] != nil {
			if err := m[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName(strconv.Itoa(i))
				}
				return err
			}
		}

	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// AssetAttributeListItems0 asset attribute list items0
//
// swagger:model AssetAttributeListItems0
type AssetAttributeListItems0 struct {

	// Extensions allowed when the attribute type is `media_file`
	AllowedExtensions []string `json:"allowed_extensions"`

	// Attribute code
	// Required: true
	Code *string `json:"code"`

	// Whether decimals are allowed when the attribute type is `number`
	DecimalsAllowed *bool `json:"decimals_allowed,omitempty"`

	// Whether the attribute should be in read only mode only in the UI, but you can still update it with the API
	IsReadOnly *bool `json:"is_read_only,omitempty"`

	// Whether the attribute should be part of the record's completeness calculation
	IsRequiredForCompleteness *bool `json:"is_required_for_completeness,omitempty"`

	// Whether the UI should display a rich text editor instead of a simple text area when the attribute type is `text`
	IsRichTextEditor bool `json:"is_rich_text_editor,omitempty"`

	// Whether the UI should display a text area instead of a simple field when the attribute type is `text`
	IsTextarea *bool `json:"is_textarea,omitempty"`

	// labels
	Labels *AssetAttributeListItems0Labels `json:"labels,omitempty"`

	// Maximum number of characters allowed for the value of the attribute when the attribute type is `text`
	MaxCharacters int64 `json:"max_characters,omitempty"`

	// Max file size in MB when the attribute type is `media_file`
	MaxFileSize string `json:"max_file_size,omitempty"`

	// Maximum value allowed when the attribute type is `number`
	MaxValue string `json:"max_value,omitempty"`

	// For the `media_link` attribute type, it is the type of the media behind the url, to allow its preview in the PIM. For the `media_file` attribute type, it is the type of the file.
	// Required: true
	// Enum: [image pdf youtube vimeo other]
	MediaType *string `json:"media_type"`

	// Minimum value allowed when the attribute type is `number`
	MinValue string `json:"min_value,omitempty"`

	// Prefix of the `media_link` attribute type. The common url root that prefixes the link to the media
	Prefix string `json:"prefix,omitempty"`

	// Suffix of the `media_link` attribute type. The common url suffix for the media
	Suffix string `json:"suffix,omitempty"`

	// Attribute type
	// Required: true
	// Enum: [text media_link number media_file single_option multiple_options reference_entity_single_link reference_entity_multiple_links]
	Type *string `json:"type"`

	// Regexp expression used to validate the attribute value when the attribute type is `text`
	ValidationRegexp string `json:"validation_regexp,omitempty"`

	// Validation rule type used to validate the attribute value when the attribute type is `text`
	// Enum: [email url regexp none]
	ValidationRule *string `json:"validation_rule,omitempty"`

	// Whether the attribute is scopable, i.e. can have one value by channel
	ValuePerChannel *bool `json:"value_per_channel,omitempty"`

	// Whether the attribute is localizable, i.e. can have one value by locale
	ValuePerLocale *bool `json:"value_per_locale,omitempty"`
}

// Validate validates this asset attribute list items0
func (m *AssetAttributeListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMediaType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationRule(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AssetAttributeListItems0) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("code", "body", m.Code); err != nil {
		return err
	}

	return nil
}

func (m *AssetAttributeListItems0) validateLabels(formats strfmt.Registry) error {

	if swag.IsZero(m.Labels) { // not required
		return nil
	}

	if m.Labels != nil {
		if err := m.Labels.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("labels")
			}
			return err
		}
	}

	return nil
}

var assetAttributeListItems0TypeMediaTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["image","pdf","youtube","vimeo","other"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetAttributeListItems0TypeMediaTypePropEnum = append(assetAttributeListItems0TypeMediaTypePropEnum, v)
	}
}

const (

	// AssetAttributeListItems0MediaTypeImage captures enum value "image"
	AssetAttributeListItems0MediaTypeImage string = "image"

	// AssetAttributeListItems0MediaTypePdf captures enum value "pdf"
	AssetAttributeListItems0MediaTypePdf string = "pdf"

	// AssetAttributeListItems0MediaTypeYoutube captures enum value "youtube"
	AssetAttributeListItems0MediaTypeYoutube string = "youtube"

	// AssetAttributeListItems0MediaTypeVimeo captures enum value "vimeo"
	AssetAttributeListItems0MediaTypeVimeo string = "vimeo"

	// AssetAttributeListItems0MediaTypeOther captures enum value "other"
	AssetAttributeListItems0MediaTypeOther string = "other"
)

// prop value enum
func (m *AssetAttributeListItems0) validateMediaTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, assetAttributeListItems0TypeMediaTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AssetAttributeListItems0) validateMediaType(formats strfmt.Registry) error {

	if err := validate.Required("media_type", "body", m.MediaType); err != nil {
		return err
	}

	// value enum
	if err := m.validateMediaTypeEnum("media_type", "body", *m.MediaType); err != nil {
		return err
	}

	return nil
}

var assetAttributeListItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["text","media_link","number","media_file","single_option","multiple_options","reference_entity_single_link","reference_entity_multiple_links"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetAttributeListItems0TypeTypePropEnum = append(assetAttributeListItems0TypeTypePropEnum, v)
	}
}

const (

	// AssetAttributeListItems0TypeText captures enum value "text"
	AssetAttributeListItems0TypeText string = "text"

	// AssetAttributeListItems0TypeMediaLink captures enum value "media_link"
	AssetAttributeListItems0TypeMediaLink string = "media_link"

	// AssetAttributeListItems0TypeNumber captures enum value "number"
	AssetAttributeListItems0TypeNumber string = "number"

	// AssetAttributeListItems0TypeMediaFile captures enum value "media_file"
	AssetAttributeListItems0TypeMediaFile string = "media_file"

	// AssetAttributeListItems0TypeSingleOption captures enum value "single_option"
	AssetAttributeListItems0TypeSingleOption string = "single_option"

	// AssetAttributeListItems0TypeMultipleOptions captures enum value "multiple_options"
	AssetAttributeListItems0TypeMultipleOptions string = "multiple_options"

	// AssetAttributeListItems0TypeReferenceEntitySingleLink captures enum value "reference_entity_single_link"
	AssetAttributeListItems0TypeReferenceEntitySingleLink string = "reference_entity_single_link"

	// AssetAttributeListItems0TypeReferenceEntityMultipleLinks captures enum value "reference_entity_multiple_links"
	AssetAttributeListItems0TypeReferenceEntityMultipleLinks string = "reference_entity_multiple_links"
)

// prop value enum
func (m *AssetAttributeListItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, assetAttributeListItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AssetAttributeListItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

var assetAttributeListItems0TypeValidationRulePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["email","url","regexp","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetAttributeListItems0TypeValidationRulePropEnum = append(assetAttributeListItems0TypeValidationRulePropEnum, v)
	}
}

const (

	// AssetAttributeListItems0ValidationRuleEmail captures enum value "email"
	AssetAttributeListItems0ValidationRuleEmail string = "email"

	// AssetAttributeListItems0ValidationRuleURL captures enum value "url"
	AssetAttributeListItems0ValidationRuleURL string = "url"

	// AssetAttributeListItems0ValidationRuleRegexp captures enum value "regexp"
	AssetAttributeListItems0ValidationRuleRegexp string = "regexp"

	// AssetAttributeListItems0ValidationRuleNone captures enum value "none"
	AssetAttributeListItems0ValidationRuleNone string = "none"
)

// prop value enum
func (m *AssetAttributeListItems0) validateValidationRuleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, assetAttributeListItems0TypeValidationRulePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AssetAttributeListItems0) validateValidationRule(formats strfmt.Registry) error {

	if swag.IsZero(m.ValidationRule) { // not required
		return nil
	}

	// value enum
	if err := m.validateValidationRuleEnum("validation_rule", "body", *m.ValidationRule); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AssetAttributeListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetAttributeListItems0) UnmarshalBinary(b []byte) error {
	var res AssetAttributeListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AssetAttributeListItems0Labels Attribute labels for each locale
//
// swagger:model AssetAttributeListItems0Labels
type AssetAttributeListItems0Labels struct {

	// Attribute label for the locale `localeCode`
	LocaleCode string `json:"localeCode,omitempty"`
}

// Validate validates this asset attribute list items0 labels
func (m *AssetAttributeListItems0Labels) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AssetAttributeListItems0Labels) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetAttributeListItems0Labels) UnmarshalBinary(b []byte) error {
	var res AssetAttributeListItems0Labels
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
